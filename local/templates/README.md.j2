# {{license["name"]}} ({{me["username"]}})

A snapshot of my activity.

[![{{license["name"]}}'s GitHub stats](https://github-readme-stats.vercel.app/api?username={{me["username"]}}&show_icons=true&theme=github_dark)](https://github.com/anuraghazra/github-readme-stats)

[![Languages](https://github-readme-stats.vercel.app/api/top-langs/?username={{me["username"]}})](https://github.com/anuraghazra/github-readme-stats)

# Quick Links

* [Python Projects](#python-projects)
* [TypeScript Projects](#typescript-projects)

# Mission

**My long-term goal is to establish an ecosystem of iteractive
resources (both hands-on via physical kits, in-person sessions and on the web)
to provide a more enriching and enjoyable experience learning about software.**

Software is nothing without hardware to execute it, and software systems that
enable mechatronic work interest me the most. Understanding software systems
end-to-end requires engineering expertise beyond writing code (mechanical,
electrical and more!). For this reason, education about software
requires non-linearity and exploration of many engineering concepts.

Why study "data structures", "algorithms" or "design patterns" without
practical problems to apply such concepts to, and opportunity complete a
learning feedback loop?

# About

I'm an engineer. I currently work on software to pay the bills and live in
society, but I use most of my personal time to build a foundation of software
and tools to march towards the [mission](#mission) stated above.

I also believe that the easiest way to get hooked on software is to get
first-hand experience with the highest gain factors: changing lines of code
and making things move. **Moving pixels is fun, but moving massive objects and
harnessing high amounts of physical power is something else entirely**.

I'm extremely fortunate and grateful for the first-hand experience I've had
to work on software that interacts with mechatronic systems. I find it highly
rewarding, but also difficult to do as a hobby.

Compute hardware like [Raspberry Pi](https://www.raspberrypi.com/),
[Arduino](https://www.raspberrypi.com/) and many others present low-cost
opportunities for hobbyist engineers to design and build electronics at home.
Today, it's still difficult for a novice to do more than blink LEDs, rotate
small DC motors, or complete boilerplate projects *(let me know if you
disagree!)*. In my limited experience trying to teach kids about programming
and electronics with these tools: blinking LEDs or making noise with a small
speaker/buzzer just isn't captivating enough to keep them interested. It's
equally uninteresting as the instructor!

I've spent hundreds of hours with [LEGO](https://www.lego.com/en-us)'s as a
kid. Physically assembling something from step-by-step instructions seems to be
enjoyable and satisfying for many of us.

This satisfaction doesn't seem to translate to typing code from a booklet into
some desktop (or browser) computer application, or downloading pre-written code
from the internet. This is true at least for myself, and I've observed the same
with people close to me that I've tried to share my passion for electronics
with.

Even if something you built was inanimate until you provided it the software -
**it matters whether or not you understand how feeding software into something
works, and especially what that software does**.

Knowing that hardware can be animated with the right software, contributing to
the solution by observing the puzzle and manipulating the pieces can require
lots of expensive tools (e.g. oscilloscopes, protocol analyzers, in-circuit
debuggers) and infrastructure (real-time telemetry, commanding, text logging)
to attempt and experience success in a tight feedback loop.

We're familiar with user interfaces that present explanations for errors (and
even suggestions for how to fix them), but **iterating on embedded software is
often extremely challenging even for veterans with decades of experience**.

This has been my personal experience trying to earn stripes as a software
engineer, but I feel that better tools could improve learning velocity and
shorten iteration times.

# Let us Begin

Join me as I try to distill what I've learned into something I can share with
you. In the end if we can manage some collective amusement, we have more
than succeeded.

We have a long way to go. Let's get to work!

## Python Projects

*What's [Python](https://www.python.org/)?*

Check out the
[YouTube series](https://www.youtube.com/playlist?list=PLTPrK33wiSsn76rMdJ7IVA1tWTcdWX0Fy)
I'm working on where I go over my workflow and document notable feature
developments.

Packages I've created are derived from
[python-package-template](https://github.com/{{me["username"]}}/python-package-template),
a custom [`cookiecutter`](https://cookiecutter.readthedocs.io/en/stable/) template.
A project template (that leverages a
[config](https://github.com/vkottler/config) repository to keep templates
synchronized in the long-term) makes it easier to start writing code as a next
step immediately after justifying a new project.

See also: [generated documentation](https://{{me["username"]}}.github.io/python/pydoc/)
(created with [`pydoc`](https://docs.python.org/3/library/pydoc.html)).
Information about each project can be found on that project's `README.md`
linked below.

{% for package in python["packages"] %}
* [{{package}}](https://github.com/{{me["username"]}}/{{package}})
{% endfor %}

## TypeScript Projects

*What's [TypeScript](https://www.typescriptlang.org/)?*

Currently working on a
[typescript-package-template](https://github.com/{{me["username"]}}/typescript-package-template)
as I delve into web front-end technologies and workflows. This template is
similar to the one I'm using for [Python projects](#python-projects).
