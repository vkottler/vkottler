# Mission

**My long-term goal is to design electronics and write software that is
practical for everyday use at home.**

Having time and resources to put towards engineering is a luxury. Without
self-sufficiencies such as:
* Growing food and raising livestock
* Having a source of fresh water
* Having land or shelter to occupy and find community

...life could demand that more primitive survival needs take priority at any
moment.

What would you do if you made a routine visit to a grocery store and there was
no food? What if there was no voltage on the wires in the walls of your
home? No natural gas to provide heat in the winter or boil water on the stove?

**I'm interested in using technology to scale this infrastructure down** so
that the average home could be equipped with:
* An off-grid battery system
* Automated watering and management of outdoor (or indoor) crops
* General automation of household electronics from the local network

...and more.

**An additional long-term goal is to establish an ecosystem of iteractive
resources (both hands-on via physical kits, in-person sessions and on the web)
to provide a more enriching and enjoyable experience learning about software.**

Software is nothing without hardware to execute it, and software systems that
enable mechatronic work interest me the most. Understanding software systems
end-to-end requires engineering expertise beyond writing code (mechanical,
electrical and more!). For this reason, education about software
requires non-linearity and exploration of many engineering concepts.

Why study "data structures", "algorithms" or "design patterns" without
practical problems to apply such concepts to, and opportunity complete a
learning feedback loop?

# About

I'm an engineer working around the clock. I'm currently focused on trying to
own a home and start a family.

I can't pursue these goals or the [mission](#mission) full-time without a real
job, so that takes priority.

I also believe that the easiest way to get hooked on software is to get
first-hand experience with the highest gain factors: changing lines of code
and making things move. **Moving pixels is fun, but moving massive objects and
harnessing high amounts of physical power is something else entirely**.

As rewarding as such work can be, it's difficult to do as a hobby.

Compute hardware like [Raspberry Pi](https://www.raspberrypi.com/),
[Arduino](https://www.raspberrypi.com/) and many others present low-cost
opportunities for hobbyist engineers to design and build electronics at home.
Today, it's still difficult for a novice to do more than blink LEDs, rotate
small DC motors, or complete boilerplate projects *(let me know if you
disagree!)*. In my limited experience trying to teach kids about programming
and electronics with these tools: blinking LEDs or making noise with a small
speaker/buzzer just isn't captivating enough to keep them interested. It's
equally uninteresting as the instructor!

I've spent hundreds of hours with [LEGO](https://www.lego.com/en-us)'s as a
kid. Physically assembling something from step-by-step instructions seems to be
enjoyable and satisfying for many of us.

This satisfaction doesn't seem to translate to typing code from a booklet into
some desktop (or browser) computer application, or downloading pre-written code
from the internet.

Creating software for hardware can also require expensive tools (e.g.
oscilloscopes, protocol analyzers, in-circuit debuggers) and infrastructure
(real-time telemetry, commanding, text logging) to be productive and
successful. **Iterating on embedded software is
often extremely challenging even for veterans with decades of experience**.

This has been my personal experience trying to earn stripes as a software
engineer, but I feel that better tools could improve learning velocity and
shorten iteration times.

We have a long way to go. Let's get to work!
